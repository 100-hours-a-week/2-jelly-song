# 📌 Java 메모리 영역과 GC, OOP, 예외 처리 개념 정리

## **1. 자바의 메모리 영역과 컴파일 과정**

### 🧠 **a. 메모리 영역**
자바의 메모리는 크게 5가지 영역으로 나뉩니다.

| 🏠 메모리 영역 | 설명 |
|---|---|
| **Heap (힙 영역)** | `new` 키워드로 생성된 객체 저장, Garbage Collector가 관리 |
| **Stack (스택 영역)** | 메서드 실행 시 생성되는 지역 변수와 메서드 호출 정보 저장 |
| **Method Area (메서드 영역, Class Area)** | 클래스의 메타데이터, 정적 변수(`static`), 메서드 정보 저장 |
| **PC Register (PC 레지스터)** | 현재 실행 중인 JVM 명령어의 주소 저장 |
| **Native Method Stack (네이티브 메서드 스택)** | JNI(Java Native Interface)로 호출되는 C/C++ 코드 실행 |

---

### ⚙️ **b. 자바의 컴파일 과정**
자바는 "컴파일 + 인터프리트" 방식을 사용합니다.

1️⃣ **소스 코드 → 바이트 코드 변환 (컴파일)**
- `javac Hello.java` → `Hello.class` (바이트 코드 생성)

2️⃣ **JVM이 바이트 코드 실행 (인터프리트)**
- `java Hello` 실행
- JVM이 바이트 코드를 한 줄씩 해석 & 실행 (JIT 최적화)

✔ **장점:** OS에 독립적인 `.class` 파일 생성 → 어디서나 실행 가능 🌍

---

## **2. 🗑️ 가비지 컬렉션(Garbage Collection)**

### 🔄 **가비지 컬렉션 정의 및 동작 방식**
💡 **"더 이상 사용되지 않는 객체를 자동으로 정리하는 기능"**

1️⃣ **객체 생성 (Heap 메모리 할당)**
- `new` 키워드로 객체 생성 후 Heap에 저장  
  2️⃣ **객체가 필요 없어짐 (Unreachable 상태)**
- 객체의 참조가 끊어지면 사용되지 않는 상태가 됨  
  3️⃣ **GC가 불필요한 객체 정리**
- GC가 주기적으로 실행되어 Heap을 정리

✔ **장점**: 메모리 관리를 자동화하여 개발자가 직접 관리할 필요 없음  
✔ **단점**: GC 실행 시 성능 저하 가능

---

## **3. 🔍 Java vs 다른 언어의 GC 비교**

### 🆚 **Python과 Java의 GC 비교**

| 🛠️ 특징 | Java | Python |
|---|---|---|
| **GC 방식** | **Mark and Sweep + Generational GC** | **Reference Counting + Generational GC** |
| **자동 관리 여부** | JVM이 관리 | Python 인터프리터가 관리 |
| **주요 문제** | GC 실행 시 일시적인 성능 저하 | **순환 참조 문제** 발생 가능 |

✔ Python은 **참조 카운팅(Reference Counting)**을 사용하여 객체의 참조 개수가 0이 되면 즉시 제거  
✔ 하지만, **순환 참조(Cyclic Reference) 문제**가 있어 GC가 보완적으로 동작해야 함

---

## **4. ⚡ Java의 GC 종류 및 차이점**

| 🔧 GC 종류 | 특징 |
|---|---|
| **Serial GC** | 단일 스레드로 실행, 작은 애플리케이션에 적합 |
| **Parallel GC** | 멀티 스레드 사용, 성능 우선 |
| **G1 GC** | 최신 GC, 짧고 빠른 GC 실행 (기본값) |
| **ZGC** | 초저지연 GC, 대용량 메모리 환경에서 적합 |

✔ 일반적으로 **G1 GC가 가장 많이 사용됨** (Java 9 이후 기본 GC)

---

## **5. ⚠️ JVM 관점에서 static을 조심해서 써야 하는 이유**
💡 **"static은 JVM 종료 전까지 메모리에 남아있기 때문"**

✔ **Heap이 아니라 Method Area(메서드 영역)에 저장됨**  
✔ 프로그램 종료 전까지 해제되지 않으므로 **메모리 누수 위험**  
✔ 멀티스레드 환경에서는 **동기화 이슈** 발생 가능

---

## **6. 🎭 OOP와 추상화, 캡슐화**

### 🏗️ **OOP (객체지향 프로그래밍) & SOLID 원칙**
객체지향 프로그래밍(OOP)은 유지보수성과 확장성을 높이는 개발 방식이다.
객체지향 프로그래밍을 실천하는 방식으로 SOLID 원칙이 있다.

✔ **추상화 캡슐화**
1. 추상화 : 불필요한 세부 정보를 숨기고 중요한 것만 표현
2. 캡슐화 : 데이터(변수)와 메서드를 하나로 묶고 접근을 제한

추상화는 주로 무엇을 해야 하는지에 초점을 맞추는 반면, 캡슐화는 그것이 어떻게 이루어져야 하는지에 초점을 맞춥니다.

✔ **SOLID 원칙**
1. **S**ingle Responsibility Principle (단일 책임 원칙)
2. **O**pen/Closed Principle (개방/폐쇄 원칙)
3. **L**iskov Substitution Principle (리스코프 치환 원칙)
4. **I**nterface Segregation Principle (인터페이스 분리 원칙)
5. **D**ependency Inversion Principle (의존 역전 원칙)

---

## **7. 🚨 Java에서 예외 처리**

### 🎯 **예외 처리의 목적**
✔ 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상적인 동작을 막고, 에러를 잡아 복구를 시도하거나 아니면 회피 하는식으로 처리를해서, 프로그램이 정상적인 실행상태를 유지할 수 있도록 하는 것이다.

### 📢 **오류(Error) vs 예외(Exception)**

| 🔍 유형 | 설명 | 예제 |
|---|---|---|
| **오류(Error)** | 시스템적인 문제 | OutOfMemoryError |
| **예외(Exception)** | 코드 실행 중 발생하는 문제 | NullPointerException |

### 📢 **확인된 예외 vs 확인되지 않은 예외**

확인된 예외 : 무조건 예외 처리를 해주어야함

확인되지 않은 예외 : 예외 처리를 해주지 않아도 자동으로 예외가 넘어감

---

## **8. 🔄 자바의 클래스 인스턴스 변수 초기화 순서**

💡 **클래스 변수의 초기화**: 클래스가 처음 메모리에 로딩될 때 단 한 번 차례대로 수행되며, 순서는 다음과 같습니다.

```
기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
```

💡 **인스턴스 변수의 초기화**: 인스턴스를 생성할 때마다 차례대로 수행되며, 순서는 다음과 같습니다.

```
기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
```

### 📌 **예제 코드**

```java
class InitTest {
    static int classVariable = 1;  // 명시적 초기화
    int instanceVariable = 1;
    
    static { classVariable = 2; } // 클래스 초기화 블럭
    { instanceVariable = 2; } // 인스턴스 초기화 블럭
    
    InitTest() { // 생성자
        instanceVariable = 3;
    }
}
```

✔ **설명:**
- **클래스 변수 (`static`) 초기화 과정**: 기본값(0) → 명시적 초기화(1) → 클래스 초기화 블럭(2) 적용
- **인스턴스 변수 초기화 과정**: 기본값(0) → 명시적 초기화(1) → 인스턴스 초기화 블럭(2) → 생성자(3) 적용

🚀 **즉, 클래스 변수는 프로그램 시작 시 한 번만 초기화되며, 인스턴스 변수는 객체가 생성될 때마다 초기화됩니다!**

