# 시간
- 09:00 ~ 18:00 : 카카오 테크 부트캠프

# 간략 회고

### 카카오 테크 부트캠프

1차 적으로 테스트 코드 작성을 완료하였다.

전체적으로 고민한 내용은 다음과 같다. PR 내용과도 같다

---

WebClient Mocking
WebClient의 경우 response가 체인으로 얽혀 있어 mocking이 쉽지 않습니다. 이를 WebServer 자체를 모킹하는 방식으로 해결하였습니다.
참고한 레퍼런스 : https://www.baeldung.com/spring-mocking-webclient

WebClient Bean 등록
Test 코드 작성 전, WebClient는 메인에 Bean으로 등록되어 있었습니다. 따라서 이 객체를 가져오기 위해서는 의존관계 주입을 받아야 했고, 테스트하기 어려운 상황이었습니다.
단순한 단위 테스트에도 동작하게 하기 위해 Bean으로 등록하지 않고 비즈니스 로직상에 WebClient 자체를 생성하도록 구성하여 해결하였습니다.
만약 WebClient 빈을 다른 클래스들이 공유하는 상황이었다면, 따로 싱글톤 객체를 반환하는 클래스를 만들었을 것 같습니다. 해당 WebClient를 한 곳에서만 사용 중 이었기 때문에 단순히 해당 서비스에서 생성하는 방식으로 해결하였습니다.

리팩토링
Test 코드를 작성하며 리팩토링을 진행하였습니다.

구 ChatRelayService(현 ChatDeliveryService)는 알림을 저장하는 기능, Relay 요청을 보내는 기능을 가지고 있었습니다. 해당 기능에 대해 구체적인 비즈니스 로직을 의존하고 있었습니다. 이에 테스트 하기에 어려움을 겪었습니다.
이를 테스트 코드가 '리팩토링을 하라는 신호'를 저에게 보내는 것으로 인식 하였습니다. 따라서 이를 ChatDeliveryService, ChatRelayService, NotificationService로 분리하였습니다.
이로써 테스트 코드를 작성에 용이함을 가져왔습니다. 또한 클래스를 분리함으로써 SRP를 지켜낼 수 있었습니다.

메인 코드에서 쓰이는 상수와 테스트 코드의 상수가 일치해야 테스트가 통과합니다. 이를 일일이 String으로 적어내기엔 어려움이 있었습니다. 이 또한 '신호'로 받아들이고 constant 패키지를 작성하여 상수를 모아놓아 테스트 작성에 용이함도 가져옴은 물론 유지보수성을 가져왔습니다.
예를 들어 재시도 횟수 2에 대해 하드코딩이 되어있었습니다. 이를 constant로 뽑아내 테스트와 메인 둘다 가져감으로 메인에서 retry 횟수가 변하더라도 테스트가 통과되는 이점을 가져왔습니다.

상세 구현 로직에 얽매이지 않는 테스트 코드

상세 구현 로직에 얽매이지 않도록 구성하였습니다.
만약 상세 구현 로직에 얽매인다면 단순한 메인 코드 리팩토링에도 테스트가 깨질 위험이 존재합니다.
해당 기능의 api, 즉 "역할"을 위주로 테스트하여 리팩토링에 강한 테스트 코드를 구성하였습니다.

참고한 레퍼런스1 : https://www.youtube.com/watch?v=APpUBvLRFJo
참고한 레퍼런스2 : https://www.youtube.com/watch?v=qQaUrk4kROk (14:50~)

임베디드 vs mock

현재 카프카, 레디스, mysql 등 많은 외부 요소들과 결합되어 있는 상황입니다. 따라서 mock을 많이 사용해야 하는 상황입니다. 이에 대해 임베디드 테스팅을 도입할지, mock을 사용해야 할지 고민이었습니다.

결국 mock을 사용하기로 결정 하였습니다. 아무래도 테스트라면 '빨라야' 많이 실행할 수 있습니다. 그로인해 프로젝트를 유지보수성 좋게 나아갈 수 있습니다.

또한 테스팅이란 해당 부분이 잘 동작하는지 보기 위해 작성하는 것입니다. 하지만 카프카를 예시로 들면, 임베디드와, 운영에서의 카프카는 다릅니다.

임베디드에서 돌아간다고, 운영에서의 카프카가 돌아간다는 보장이 없습니다. 운영에서의 설정을 임베디드에서 똑같이 할 수는 없기 때문입니다. (카프카 서버 여러개 증설 및 네트워크 타기)

카프카의 동작은, 카프카 그 자체의 책임이므로 그것을 mock으로 도입하는 것에 문제가 없다고 판단하였습니다.

에러 처리
ChatRelayService의 webClient 관련 test 코드를 짜며 "에러 처리"에 관해 부족함이 있는 코드임을 깨달았습니다.
Kafka 설정으로 ErrorHandler를 적용하였지만 webClient에서 나오는 에러는 처리하지 못하기 때문입니다.
이것을 테스트 코드가 알려주는 "신호"를 캐치하고 webClient에서 Error가 발생한다면 Dlq에 해당 내용을 프로듀스 하도록 개발하고 테스트 하였습니다.

---

PR 링크 : https://github.com/100-hours-a-week/19-Respec-BE-Chatconsumer/pull/17

지금 ChatConsumerService 부분에 대한 리팩토링을 진행중인데 역시 개발은 끝이 없다는 것을 느낀다.

여기서 좀 더 유지보수성을 늘리는 쪽으로 고도화를 한다면 헥사고날 아키텍처, DDD, 관심사의 분리 등 할 것이 많다고 생각한다.

성능 고도화 쪽으로 가면 캐싱, MSA, DB 하이브리드 등 넓혀나갈 것이 많다.

당연한 말일 수 있지만 꾸준한 공부 및 적용이 중요한 것 같다. 그러면 장단점을 명확히 알 수 있고 해당 프로젝트에 알맞는 최선의 방법을 적용 할 수 있기 떄문이다.


