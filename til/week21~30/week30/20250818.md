# 시간

- 09:00 ~ 18:00 : 싸피
- 20:00 ~ 22:00 : 에이블리 자소서 작성
- 22:00 ~ 24:00 : 카프카 exactly-once 구현

# 간략 회고

### 카프카 exactly-once 구현

저번 프로젝트에서 구현했던 exactly-once를 고도화 작업 진행해보았다.

프로듀서에서의 멱등성은 Pid와 seq-number를 이용한 설정을 카프카 단에서 지원을 하고 있기 때문에 손쉽게 구현을 할 수가 있었다.

다만 consumer의 멱등성에서 문제점을 발견하였다.

레디스 분산락을 이용해서 consumer의 코드가 실행되기 때문에 만약에 다른 컨슈머가 같은 메세지를 소비했다고 하더라도

분산락으로 막혀있어 해당 부분을 처리하지 못하고 return 되도록 구현을 했었었다.

그런데 만약 처음 컨슈머가 실행하고 에러가 나거나 컨슈머 서버 자체가 중단되는 일이 발생되었을때 문제가 발생한다.

그 코드를 다시 실행해야 하는데 이미 redis 값에 실행을 했다는 상태가 들어가서 단순히 return 되어 지기 때문이다.

즉 중복 소비는 해결할 수 있지만 오류가 났을때 재시도하는 동작이 막혀버린다.

처음에는 이를 try catch로 오류가 발생하면 redis 분산락을 풀어버리는 로직을 구상하였다.

다만 이 로직도 결국에는 컨슈머 서버의 갑작스러운 종료는 대비하지 못한다. 레디스 분산락을 푸는 catch 부분이 실행되지 않기 때문이다.

이를 대비하는 방법으로 2가지를 생각할 수 있었다.

첫 번째는 upsert 방식이다.

redis를 사용하지 않고 데이터베이스를 이용한 방법이다.

지금 redis를 사용해서 문제가 발생했고 redis를 사용한 이유는 중복처리를 위해서 인데, upsert를 사용한다면 중복 처리 자체를 데이터 베이스에

위임할 수 있으므로 문제가 해결된다.

두번째는 redis에 처리되는 상태 값을 기록하는 방법이다.

redis에서 proceeding, done 같은 상태값을 기록한다.

그러면 컨슈머가 들어왔을 때 proceeding 상태로 기록하고 정말로 로직이 에러 없이 끝났을 경우 done으로 기록하는 것이다.

그러면 다른 컨슈머가 들어와서 확인을 했을때 proceeding일 경우 스핀락을 돌리고 done이 되면 스핀락에서 나온 뒤 단순 return

done이 안되고 proceeding 상태의 ttl이 끝날 경우에는 done이 되지 않았음으로 판단하고 들어가서 로직을 처리하는 방법이다.

물론 두번째 방법의 경우에 redis와 consumer가 카프카에 commit 보내는 것이 원자성이 보장되는 것이 아니므로

아주 그 찰나의 순간에는 보장이 되지 않을 수가 있다. 만약 그 순간 마저도 보장을 하고 싶으면 upsert 방식으로 구현을 해야할 것 같다.