# 시간
- 09:00 ~ 18:00 : 싸피
- 22:00 ~ 24:00 : 프로젝트 고도화
-
# 간략 회고

### 프로젝트 고도화

프로젝트 고도화를 진행하였다.

챗 컨슈머에서 카프카 Config에 대한 고도화를 진행했다.

과거의 config 파일의 경우 DefaultErrorHandler 에서 Deserialize Error 및 Runtime Error를 모두 처리하면서

레코드를 직접 생성하고 헤더를 넣으며 dlq 프로듀서로 직접 전송하였다.

마치 스프링에서 어노테이션 기반 스프링 mvc를 사용하는 것이 아니라 서블릿으로 코딩하는 느낌이었다.

이를 DeadLetterRecoverer를 이용하여 가독성 좋게 코드를 수정하고, 본래 Deserialize 와 Runtime Error 모두 하나의 Dlt에서

관리 했던 점을 따로 분리하여 역할 별로 dlt 토픽을 분리하였다.

이 설정을 진행하며 카프카의 에러 핸들링 방식을 다시 한번 복습하는 계기를 가졌다.

우선 컨슈머에서 브로커에 있는 레코드를 가져오고 역직렬화가 실패하면 DeserializeErrorHandling에서 해당 값을 null로 바꾸고

에러 정보를 Header에 넣은 뒤 @KafkaConsumer에 넘겨 준다. 그러면 역직렬화 오류로 인한 무한 재반복은 해결된다.

그 뒤는 DefaultErrorHandlier의 몫인데 거기에서 일어나는 에러 들에 대해서 이 handler가 해결한다.

예를 들어 null 값을 경우에는 DeserializeError가 발생하도록 설정하여 이를 dlq에 보내도록 설정할 수 있다.

또한 다른 runtimeException 같은 경우에도 이 DefaultErrorHandler에서 설정할 수 있으며 retry 로직으로 만약 데이터베이스에서

잠시 에러가 났다 던지 같은 상황에서 정상적으로 동작할 수 있도록 설정도 가능하다. 만약 설정한 retry를 전부 돌았음에도 불구하고

에러가 난다면 이 레코드에 대해서도 dlt에 넣는 것이 가능하다.