# 시간

- 09:00 ~ 18:00 : 싸피
- 20:00 ~ 24:00 : 면접 대비

# 간략 회고

### 면접 대비

면접이 잡혀 다시 나의 프로젝트에서 어찌 더 고도화 시킬 수 있을지, 부족한 부분은 없었는지에 대해서 생각해보는 시간을 가졌다.

전체적으로 흝어 보았지만 그중에서 컨슈머에서의 멱등성 처리를 고도화 할 부분에 대해서 생각한 것이 수확이라 생각하여 기록하려 한다.

컨슈머에서의 멱등성을 처음에는 간단히 redis 분산 락을 도입하였다. 컨슈머가 poll을 하게되면 1 2 3 4 5 이렇게 여러개의 레코드들이

들어오게 되는데 3까지만 처리를 하다가 컨슈머가 죽으면 다시 1 2 3 4 5를 가져오게 되고 1 2 3을 중복 처리하게 되는 문제점이 생긴다.

따라서 해당 레코드들에 대해서 레디스에 처리를 했다는 처리를 기록하여 해당 기록이 되어있다면 처리를 하지 않는 방식이다.

하지만 초반에는 그 기록이 되어있는지 체크를 하고 되어있지 않다면 들어가서 처리를 하는 로직을 진행하였다. 그런데 만약 3번에서

처리를 하다가 중간에 에러가 나면 redis에 처리를 했다는 기록은 되어있는데 처리를 하지 않아 누락이 되는 문제가 발생할 수 있었다.

따라서 처리가 끝나는 마지막에 redis에 체크는 하는 방식으로 이를 해결할 수 있었다. 다만, 결국 레디스에 기록하는 것과 mysql에 채팅을 저장하는 것은

다른 서드파티의 결합으로 이 중간에 에러가 나는 것은 어찌 할 방도가 없다는 단점이 있다. 이를 해결하기 위해 upsert 로직을 적용할 수 있다.

upsert를 초반부터 적용하지 않았던 이유는 primary key를 uuid로 변경해야 한다는 단점이었는데, 정렬이 되어있지 않은 값이다보니 인덱싱 페이지 분할

이 일어날때 많은 리소스 소모가 든다는 단점이 있었다. 이를 snowflake를 생성하는 방식으로 해결할 수 있었다. snowflake는 정렬된 값으로 이런

인덱싱 페이지 분할에 있어서 리소스 소모가 크지 않기 떄문에 이를 활용하여 upsert 로직을 구성한다면 해결이 가능하다.