# 시간

- 10:00 ~ 12:00 : NHN 코딩 테스트
- 13:00 ~ 14:00 : 이비인후과
- 14:00 ~ 15:00 : 안경 맞추기
- 15:00 ~ 16:00 : 개발자 유미 레디스
- 16:00 ~ 18:00 : mySQL CS 공부
- 20:00 ~ 23:00 : 알고리즘 공부

# 간략 회고

### 개발자 유미 레디스

저번엔 레디스에 대해서 이론적으로 공부를 했고 개발자 유미에서는

코드로 실습하는 부분이 있어서 해당 부분을 수강하였다.

어찌 replica가 레디스 코드상에서 동작하는지 확인해보는 계기가 되었다.

### mySQL CS 공부

우아한 테크 테코톡을 이용해서 CS 공부를 틈틈히 공부하고 있다.

가장 인상깊었던 내용은 인덱스 동작 방식이다.

우선 인덱스를 등록하면 해당 인덱스에 대해 BTree가 만들어 진다. 그리고 리프 노드에 해당 데이터에 대한

페이지 번호가 적혀있어 바로 해당 페이지로 넘어가서 데이터를 읽어오는 방식이다.

만약 프라이머리 키가 있는 테이블의 경우에는 좀 다르다.

리프 노드에 페이지에 대한 주소 정보가 있는 것이 아니라 해당 프리이머리 키의 값이 들어가 있다.

그러면 해당 프라이머리 키를 이용해서 프라이머리 키로 정렬된 BTree를 다시 타게 되고 리프 노드에 있는

데이터를 읽고 가져오게 된다.

### 알고리즘 공부

이번에 비트 마스킹 문제를 2문제 풀어보았다.

처음에는 visited를 boolean 배열을 이용하여 작성하였는데, 다른 사람들 풀이를 보니

비트 마스킹을 이용해서 visited 배열을 메모리 및 시간복잡도에 있어서 효율적으로 사용할 수 있었다.

예를 들어 30개의 방문을 표현하려면 원래는 8번을 돌면서 true를 해주었어야 하는데 (1<<30) -1 로 빠르고 간편하게

표현하고 연산할 수 있었다.

visited 관련으로 비트마스킹을 유용하게 사용할 수 있겠다는 생각을 하였다.

또한 구현 문제를 풀었는데 나는 ArrayList를 이용해서 문제를 풀어 내었다. 특정 인덱스에 조회하고 삭제하는 연산이라

LinkedList를 사용해도 삭제하는 부분까지 이동하려면 O(N)의 시간이 들기 때문에 ArrayList가 삭제가 O(N)이

들더라도 시간 복잡도상 똑같기 때문이다.

다른 사람들 풀이를 보니 메모리 풀 방식으로 LinkedList를 직접 구현하고 풀이한 것을 보았다.

메모리 풀 방식은 new 연산 및 가비지 컬렉터의 리소스를 사용하지 않기 때문에 극도의 성능 최적화를 하고 싶다면

이것을 사용할 수 있다. 이는 테스트 케이스가 많은 문제들에 대해서 사용할 수 있다.

테스트 케이스가 반복 될때마다 new 연산을 쓰게 되는데 이를 메모리 풀 방식으로 하면 재사용하기 떄문에 해당 리소스가 사라지기 떄문이다
