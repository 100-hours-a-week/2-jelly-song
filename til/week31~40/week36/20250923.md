# 시간

- 09:00 ~ 18:00 : 싸피
- 20:00 ~ 24:00 : 포트폴리오 복습


# 간략 회고

### 포트폴리오 복습

목요일에 면접이 잡혀 제출했던 포트폴리오 내용에 대해서 복습을 진행하였다.

이번엔 RankingBoard 개선 부분을 중점적으로 복습하였다.

1. 레디스 캐싱

PER 알고리즘을 이용해서 캐시 스탬피드를 방지한 경험이 있다.

PER 알고리즘을 사용한 이유는 확률적으로 접근하기 때문에 스레드 마다 갱신할 캐시 만료 시간이 모두 달라

캐시 스탬피드를 방지할 수 있고

lock 방식에 비해서 미리 선제적 갱신을 시도하기 때문에 lock으로 인한 대기 하는 스레드가 생기지 않기 때문이다.

다만 PER 알고리즘의 극소한 확률에 의해 ttl이 만료되어 캐시 스탬피드가 발생할 수 있는데 이부분에 대해서는

lock 방식을 활용해서 캐시 스탬피드를 방지하는 하이브리드 전략을 사용할 수 있다.

캐시 페네트레이션의 경우에는 나의 경우 커서 기반 페이지네이션으로 무한 스크롤을 구현했는데, 만약 게시글이 삭제가 되어서

사용자들이 해당 게시물에 대해서 조회를 할 때  없는 게시물이기 때문에 캐시가 아닌 직접 db에 접근하는 캐시 페네트레이션

현상이 발생할 수 있었다. 이를 null 캐싱하여 해결하였다.

2. 쿼리 성능 향상

쿼리 성능 향상은 3가지를 이용해서 성능 향상했다.

RaningBoard의 경우에는 limit 10으로 10개씩 스펙 정보를 불러오게 된다.

쿼리 분석 결과 10개의 엘리먼트들에 대해 공통적으로 쓰이는 "총 유저 수" 같은 메서드를 반복 호출 하는 것을 확인할 수 있었다.

이런 부분을 제거하니 1500ms -> 150ms 정도로 감소 시킬 수 있었다.

다만 여기서 끝나기엔 100ms 안으로 api 호출을 감소 시켜야 사용자 경험에 좋을 수 있다고 판단하여 더 진행하였다.

메서드 호출 ms를 찍어본 결과 직무별 유저 count를 세는 부분과. 스펙을 가진 유저의 수를 세는 부분에 대해 ms가 대부분 차지한다는

것을 확인할 수 있었다.

직무별 유저 count를 세는 부분은 직무별로 count를 세지 않고 한번에 count를 읽을 수 있도록 group by 절을 활용했고

스펙을 가진 유저의 수는 드라이빙 테이블이 한번 읽고 계속 드라이븐 테이블을 읽는 조인 구조에서

DISTINCT를 이용해서 조인 구조를 없앰으로써 성능 개선을 하였다.

그 결과 60ms 로 개선할 수 있었다.

60ms 면 충분히 운영할 수 있는 수치라고 생각했고. 나머지 부분은 6ms를 10번 호출 하는 것이기 떄문에 쿼리 향상은 크게 의미가

없다고 생각했다.

만약 여기서 더 한다고 가정하면 10개의 페이지네이션을 한번에 가져오지 않고 하나씩 가져오는 부분을 한번에 벌크 쿼리 연산으로

가져오는 부분에 대해서 고민해야할 것 같다.