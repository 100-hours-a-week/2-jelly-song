# 시간
- 09:00 ~ 18:00 : 카카오 테크 부트캠프

# 간략 회고

### 분산 아키텍처

분산 아키텍처에 대한 설계를 컨펌 받았다.

이번에 분산 환경에서의 아키텍처를 처음 도전해 보았고 카프카 및 인프라에 대한 공부를 진행하였다.

다행히 방향성이 맞았고 강사분께서 방향성이 맞다고 계속 쭉 하면 될 것 같다. 라고 말씀해 주셨다.

오늘 큰 수확은 카프카 exactly-once에 대한 것에 대한 이해, Event-driven-architecture에 대한 완전한 이해이다.

카프카 코드를 보면서 의문점으로는 카프카에 queue를 넣었는데 스프링내 트랜잭션이 실패하면 어쩌지?

라는 등의 의문점이었다.

총 3가지로 분류할 수 있다. producer, consumer-producer, consumer

첫번째 producer 즉 큐에 넣는 작업은 단순히 kafka에 멱등성 옵션을 설정하므로써 달성할 수 있다.

해당 옵션을 설정하면 PID와 메세지 순서를 카프카에서 보관하고 같은 PID와 메세지 순서를 가진 레코드가 들어오면 폐기하는 메커니즘으로 동작해서 중복을 허락하지 않는다.

두번째 consumer-producer는 kafka transaction-id로 해결 가능하다.

consumer을 하고 작업을 한 뒤 3개의 레코드를 다 producer 한다고 가정하면 3개의 레코드 모두 트랜잭션 단위로 묶여야 한다. 이를 해결해 주는 것이 kafka transaction이다.

마지막으로 consumer는 upsert 또는 redis를 활용하여 멱등을 보장할 수 있다.

upsert 방식은 새로운 것일 경우 insert, 원래 있던 값을 경우 update를 하는 방벙비다.

redis는 history를 저장하고 원래 왔던 값일 경우 폐기하는 방식이다.

제일 문제 였던 exactly-once 문제를 해결한 것이 오늘의 수확이었고 다른 부분도 많이 학습하였다.

예를 들면 카프카 4.0.0 버전이 출시되어서 이 카프카를 도입하는 것에 대한 고민도 있었다.

하지만 요즘 주키퍼를 쓰지 않고 Kraft 모드로 사용했을 때 문제가 많아 말이 많이 돌고 있다는 사실을 알게 되었고 도입을 하지 않았다.