# 시간
- 09:00 ~ 18:00 : 싸피
- 20:00 ~ 24:00 : 스프링 부트 대용량 트래픽 인강 완강

# 간략 회고

### 스프링 부트 대용량 트래픽 인강 완강

스프링 부트 대용량 트래픽 인강을 완강하였다.

저번 프로젝트에서 고려했었던 내용을 담고 있었기 때문에 많은 인사이트를 얻을 수 있는 강의였다.

가장 인상 깊었던 부분은 CQRS 였다.

스프링 부트 프로젝트 안에서 Query와 Command를 분리 시켜서 코드를 작성하는 방법은 알고 있었다.

이런데 이 개념이 MSA 아키텍처에서도 사용된다는 점이 인상 깊었다.

이 방법으로 내가 궁금해하고 있었던 부분 하나를 해결할 수 있었다.

MSA 아키텍처에서 만약 게시글 서비스가 있다고 가정했을때 게시글 서비스는 댓글, 조회수, 좋아요 서비스에 REST API 요청을 보내서 해당 게시글에 대한 정보를 받은 뒤에 클라이언트에게 조인하여 응답해야 한다.

나는 이 아키텍처를 보고 너무 네트워크 연산 같은 것이 많이 발생하고 의존관계가 크지 않나 라는 생각을 했었다.

그런데 이 강의에서는 해당 부분을 CQRS를 도입함으로써 해결하였다.

Query에 관련된 부분을 담당한는 서버를 따로 구축하는 것이다.

이 QUuery에 관련된 부분을 담당하는 서버를 데이터 베이스도 따로 가지고 있고 이미 Kafka로 이벤트를 발행하는 부분은 구축되어 있으니 해당 부분을 consume하고 데이터베이스에 반정규화된 상태로 저장하는 것이다.

물론 이 부분들 말고도 배울 점은 많았다.

나는 저번 프로젝트에서 선제적 갱신 기법, PER 알고리즘을 도입해서 캐시 스탬피드를 대비한 경험이 있다.

이 강의에서도 해당 문제를 거론했는데 이 부분에 대해서는 따로 논리적 ttl와 물리적 ttl을 두는 방법을 구상하였다.

만약 논리적 ttl이 발생하면 캐시를 갱신하는 service에 요청하고 해당 service는 요청한 서버에 대해서 분산 lock을 건다.

그러면 다른 서비스 들이 논리적 ttl이 갱신해서 캐시를 갱신하는 service에 요청을 해도 lock이 존재하지 않으니 원래대로 캐싱 로직을 진행하고

락을 가진 서버는 캐싱을 갱신하는 역할을 부여 받아 캐시를 갱신한다.

나의 방법과 비슷한 메커니즘이라는 것을 이해했고, 어떤 문제를 해결하기 위해서 다양한 문제 해결 방안이 있다는 사실을 깨달았다.

덧붙여서 여기에서는 최신 글 1000개에 대해서 레디스 캐싱을 진행했는데 나의 프로젝트에서 랭킹 TOPN 에 대해서 캐싱을 했던 경험과 일맥 상통하다는 것을 깨달았다.

전반적으로 저번 프로젝트에서 적용했던 내용이 적합했음을 확인하는 기회가 되었고 사용 기술에 대해 문제점이 발생하면 해결하는 방식이 어려가지 있다는 것을 알게 되었다. 시야를 넓히게 되는 계기가 되었다.
