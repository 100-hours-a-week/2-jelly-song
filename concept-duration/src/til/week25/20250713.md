# 시간
- 15:00 ~ 17:00 : 프로젝트 고도화
- 19:00 ~ 21:00 : 전화 영어
- 21:00 ~ 24:00 : 프로젝트 고도화

# 간략 회고

## 프로젝트 고도화

오늘 진행된 고도화 목록은 다음과 같다.

1. 프론트에서 상태관리하는 isBookmarked 필드 제거

2. ttl의 남은 %를 기반으로 선제적 갱신 -> PER 알고리즘을 적용한 캐싱

3. getRanking 성능 개선

### isBookmarked 필드 제거

프론트에서 로그인할때 자신의 즐겨찾기 목록을 가져온다.

따라서 getRankings에서 즐겨찾기 목록을 "계속해서 api 호출할 필요가 없다."

즉 프론트에서 상태관리를 한다면 로그인 할때에만 db에서 즐겨찾기 목록을 가져오고, 그뒤로는 bookmark에 대한 db 접근을 하지 않는다.

따라서 isBookmarked 필드를 제거한다.

### ttl의 남은 %를 기반으로 선제적 갱신 -> PER 알고리즘을 적용한 캐싱

전의 캐싱의 경우 단순 jitter를 적용한 선제적 갱신이었습니다.

이를 선제적 갱신에서 효과적인 알고리즘으로 알려진 PER 알고리즘으로 전환합니다.

beta와 같은 파라미터로 선제적 갱신을 얼마나 자주 적용할지 선택할 수 있습니다.

또한 캐시를 계산하기 위해 걸린 "계산 시간"을 기반으로 확률적으로 캐싱 refresh을 적용하여 효율적인 선제적 갱신이 가능합니다.

### getRanking 성능 개선

1) countUsersHavingSpec의 경우 호출 시 공통된 값을 가져옵니다. 이를 공통으로 분리하여 중복된 쿼리를 제거합니다.
평균 1200ms -> 200ms로 개선

2) 스펙이 존재하는 유저 수를 유저테이블에서 스펙 테이블을 조인하고 찾아내는 구조였습니다.
이를 스펙 테이블을 기준으로 distinct 유저를 사용하도록 변경합니다.
이렇게 진행하면 조인을 하지 않으므로 성능이 개선됩니다.
평균 200ms -> 120ms 개선되었습니다.

총 1200ms -> 120ms로 개선, 캐싱이 아닌 쿼리만으로 90% 개선 완료.

이정도면 쿼리 성능 최적화가 충분히 되었지만 여기서 나는 좀 더 나아갔다.

성능 최적화를 하기 위해서 고려한 사항들이다.

1* 인덱스 정순 스캔 : 기각 되었다. desc로 바꾸면 성능이 오히려 떨어진다. gt 연산을 사용해서 몇등인지 알아내기 때문에 desc가 아니라 asc가 정순 스캔이다.

2* RANK() 네티이브 쿼리 도입: 기각 되었다. RANK() 연산은 모든 랭크 들에 대해 NlogN의 시간복잡도로 연산하므로 오히려 리소스가 더 크게 들었다. 10개에 대해서만 인덱스를
활용해서 랭킹 계산을 하는 것이 오히려 경제적이다.

3* 벌크 쿼리: 페이지네이션으로 10개를 가져오므로 db에 10번 쿼리를 날리게 된다. 이를 벌크 쿼리로 한번에 가져오는 연산에 대해 고민하였다. 페이지네이션 10개를 분석한결과
그 중 각 spec에 대한 JobField를 가져오는 부분이 50ms 정도로 많은 양을 차지하였다. 이를 벌크 쿼리로 전환하였다. 14.4%의 성능개선이 되었다. 생각보다 많은 성능 개선이 되지는 않았다. 그 이유는 애초에 지금 ms가 적기도 하고, db에 다녀오는 10번의 순간만 최적화 되는 것이지 결국 JobField 들에 대해서 count 하는 연산은 그대로 이기 때문이다.

이로써 최적화를 완료하였다.
