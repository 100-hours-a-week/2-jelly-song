# 시간
- 09:00 ~ 18:00 : 카카오 테크 부트캠프
- 20:00 ~ 23:00 : SWEA D4 2문제
- 23:00 ~ 24:00 : 전화 영어

# 간략 회고

### 비동기 아키텍처 구축

현재 채팅 백엔드 로직을 설계 중이다.

초반 설계에서 문제가 되었던 점은 분산 환경에서 다른 ec2의 사용자를 모르는 문제가 발생한다는 점이었다.

ec2가 1,2,3,4,5 가 있다고 가정했을때 사용자 두명이 ec2 1, 2에 들어간다면 각각의 사용자들은 다른 사용자들을 알 수 가 없다.

이를 해결하기 위해 외부 브로커인 kafka를 도입하였다.

그런데 kafka의 경우에는 stomp를 지원하지 않아서 이것을 구현해 주어야 했다.

그 방법으로 ec2 각각이 다른 consumer group을 가지고 consume 한 뒤 해당 유저를 로컬에 가지고 있으면 채팅 메세지를 보내주는 방식이다.

근데 이 방식은 자신이 가지고 있지 않는 사용자의 메세지 마저 받은 뒤 자신의 사용자 인지 판별하는 로직이 계속 실행 되어야 한다는 문제점이 있었다.

계속 필요없는 네트워크 트래픽과 밸리데이션 로직이 실행되는 것이다.

또 이것을 해결하기 위해 공유 메모리를 도입하기로 결정하였다.

이 공유 메모리는 어떤 유저가 어떤 server 즉 ec2에 들어가 있는지 저장하는 메모리 이다.

이 공유 메모리를 활용하여 해당 사용자가 어디에 있는지 판별하고 그쪽으로 요청을 보낼 수 있다.

근데 또 문제가 발생하였다. ec2가 2개 정도라면 상관없지만 10개 또는 그 이상으로 늘어난다면 요청이 그물망처럼 복잡해지는 문제가 생겼다.

이를 해결하기 위해 kafka를 다시 도입하였다.

즉 공유 메모리 및 kafka를 사용하였다.

kafka를 도입함으로써 중간 복잡한 그물망이 하나의 queue에만 들어가면 알아서 consumer가 처리해주니 로직이 간단해 졌다.

또한 채팅에 접속해 있는지 아니면 오프라인인지에 따라 알림을 보내야 하는 문제점도 같이 해결되었다.

그 이유는 공유 메모리를 도입했기 떄문인데 여기에 사용자가 접속해 있는지 아닌지에 대한 정보가 남아있기 때문이다.

따라서 consumer가 공유 메모리를 참조하고 사용자가 없다면 push 알림을 보내면 된다.

또 여기서 문제가 발생하였다. 공유 메모리의 데이터에 대한 정합성 문제이다.

만약 클라이언트가 정상적으로 종료하지 않으면 웹소켓을 종료했다는 요청이 제대로 들어가지 않아 공유 메모리에 사용자가 접속해 있다고 잘못 저장되어 있을 수 있다.

이 떄에는 consumer가 해당 ec2 서버에 오프라인된 사용자인데 메세지를 보내라고 요청을 보내기 때문에 문제가 생겼다.

이 부분은 ec2 로직을 변경하므로써 해결하였다.

만약 ec2 로컬 메모리안에 해당 사용자가 들어있지 않다면 이것은 공유 메모리의 문제라고 판단할 수 있다.

그러면 메세지를 보내는 것이 아니라 해당 사용자에게 해당 ec2가 푸쉬 알림을 보내고 공유 메모리에 해당 값을 삭제하므로써 정합성을 지켜낼 수 있었다.

이렇게 분산 환경에서 제대로 동작하는 채팅 서버 아키텍처를 설계 완료하였다.