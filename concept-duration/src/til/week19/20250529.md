# 시간
- 09:00 ~ 21:00 : 카카오 테크 부트캠프
- 23:00 ~ 24:00 : 전화 영어

# 간략 회고

### 분산 아키텍처 설계

분산 환경에서의 채팅 서버 아키텍처를 설계하고 있다.

분산 환경이기 때문에 몇가지 이슈들이 있었다.

1. 로드 밸런싱 ec2 내려가는 문제

만약 유저들이 많아서 ec2가 10개 떠져 있었다고 가정을 했을 때, 유저들이 줄어들었다고 가정해 보았다.

그러면 이제 ec2 하나를 줄여야 하는 상황이다.

하지만 적은 유저들이라도 ec2 10개에 고루 분산되어 있는 상태이기 때문에 함부로 내릴 수 없다고 생각하였다. 그 이유는 그 ec2가 상태성을 가지고 있기 때문이다.

웹 소켓을 연결했기 때문에 해당 유저는 해당 ec2에 종속되어 있었다.

ec2에 있는 websocket을 다른 ec2로 이동시키는 코드를 작성할까 했지만 볼륨이 크다고 생각하였다.

클라이언트에서 close 이벤트를 감지할 수 있는 것이 있어서 해당 ec2가 내려가면 close 이벤트로 다른 ec2에 바로 접속하는 코드를 만드는 것이 경제적이라고 판단했다.

2. 멱등성 문제

카프카에서 exactly-once를 구현하기 위해 고민을 진행 중이다.

우선 프로듀서에서 카프카로의 트랜잭션 문제는 outbox를 도입을 고려하고 있다. 카프카 큐에 넣는 것과 데이터베이스에 넣는 것을 같은 원자성으로 묶어야 했다.

이유는 데이터베이스에 채팅을 저장하는 것과 카프카 큐에 채팅으 보내는 것은 원자성을 보장해야 하기 때문이다.

스프링 코드내에서는 그것을 보장하지 못했고 outbox 테이블을 만들고 해결하는 방법이 있어 도입을 검토 중이다.

또한 컨슈머에서 멱등성을 보장해야 했다.

카프카의 프로듀서는 정확히 exactly-once를 보장하지 못한다. 물론 그렇게 하기 위한 여러가지 설정이 있지만 정확히 보장하지는 못한다.

리밸런싱 같은 예외적인 상황에서 중복 처리를 할 수 있는 문제가 있다. 따라서 컨슈머에서는 멱등성을 보장하기 위한 코드를 작성해야한다.

만약 데이터베이스에 저장하는 것이었다면 upsert를 이용해서 해결할 수 있다. 없다면 insert 있다면 update를 하므로써 멱등성을 보장할 수 있었다.

하지만 나의 consumer는 데이터 베이스에 저장하는 것이 아니라 어느 ec2에 채팅 전송을 요청할 지 선택하는 consumer 이었기 때문에 해당 upsert 전략을 사용할 수 없었다.

따라서 멱등성을 지키는 방법 중 redis를 활용하여 빠르게 조회하고 중복 처리를 진행하는 방법을 차용하는 것을 검토하고 있다.